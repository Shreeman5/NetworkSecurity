

This is a normal run(example) of the program. I will show you how to read the outputs in terminal.
I say example because variables will be different in each run.
--------------------------------------------------------------------------------------------
1. Run Bob.py and Alice.py in that order in 2 terminals. Set mode in line 106 of Alice.py to 'good'.

START OF HANDSHAKE PHASE:

2. Go to Alice.py's terminal and read these outputs:
	
	a: R_Alice generated by Alice:  8d12a1d6
	b: Alice has sent the first message to Bob, which contains a certificate signed by the 
	   public key of Alice(K_a), supported encryption algorithm which is AES, supported integrity protection algorithm which is SHA-256, and R_Alice

3. Go to Bob.py's terminal and read these outputs:

	a: Bob has received the first message from Alice, which contains a certificate signed by the public key of Alice(K_a), supported encryption 
	   algorithm which is AES, supported integrity protection algorithm which is sha256, and R_Alice
	b: By checking the certificate and who it is signed by, Bob determines that this is Alice
	c: Bob decodes the supported encryption algorithm(non-negotiable) to be: AES
	d: Bob decodes the supported integrity protection algorithm(non-negotiable) to be: sha256
	e: Bob decodes R_Alice to be: 8d12a1d6
	f: K_a: Public RSA key at 0x1F68FF1EC20
	g: R_Bob generated by Bob:  4316dbb5
	h: Using the certificate, Bob finds the public key of Alice and uses that to encrypt R_Bob
	i: Bob has sent the second message to Alice, which contains a certificate signed by the public key of Bob(K_b),and K_a{R_Bob}

4. Go to Alice.py's terminal and read these outputs:

	a: Alice has received the second message from Bob, which contains a certificate signed by the public key of Bob(K_b),and K_a{R_Bob}
	b: By checking the certificate and who it is signed by, Alice determines that this is Bob
	c: Alice decrypts R_Bob using her private key, which turns out to be: 4316dbb5
	d: K_b: Public RSA key at 0x140EBB93D60
	e: Alice generates a random number called S, which is: 82133ecc
	f: Alice computes the Master Secret K(S xor R_Alice xor R_Bob) to be: 4c1744af
	g: Alice has sent the third message to Bob, which contains K_b{S} and the combined hash of K, message 1, message 2 and "CLIENT"or"CORRUPT"

5. Go to Bob.py's terminal and read these outputs:

	a: Bob has received the third message from Alice, which contains K_b{S} and the combined hash of K, message 1, message 2 and "CLIENT" or "CORRUPT"
	b: Bob decrypts S, using his private key, to be: 82133ecc
	c: Bob computes the Master Secret K(S xor R_Alice xor R_Bob) to be: 4c1744af

	d1: Bob will find the keyed hash function, which is a digest of K, message 1, message 2 and "CLIENT"/"CORRUPT"
	d2: Bob just generated K, he knows message 1 and message 2 and he can generate a string "CLIENT"/"CORRUPT"
	d3: Bob will know do a hash on his end by using K, message 1, message 2 and "CLIENT"/"CORRUPT"
	d4: If the hash that Bob generated matches the hash that Alice sent, Alice has been fully authenticated to Bob

	e: Since the hashes match, this is Alice. Alice has been fully authenticated to Bob.

	f: Bob has sent the fourth message to Alice, which contains the combined hash of K, message 1, message 2 and "SERVER"
	
	g: Using the hash(K, R_Alice, R_Bob), four keys are produced by Bob.
	h1: Key encryption write:  cb5b57aa3a630ff9
	h2: Key encryption read:  8e3ffebe8d268630
	h3: Key integrity protection write:  6e65f62c8fb345ad
	h4: Key integrity protection_read:  2d3fa43b0848c5dd

	i: SSL Handhsake is complete

6. Go to Alice.py's terminal and read these outputs:

	a: Alice should receive the fourth message from Bob, which contains the combined hash of K, message 1, message 2 and "SERVER"

	b1: Alice will find the keyed hash function, which is a digest of K, message 1, message 2 and "SERVER"
	b2: ALice just generated K, she knows message 1 and message 2 and she can generate a string "SERVER"
	b3: Alice will know do a hash on her end by using K, message 1, message 2 and "SERVER"
	b4: If the hash that Alice generated matches the hash that Bob sent, Bob has been fully authenticated to Alice

	c: Since the hashes match, this is Bob. Bob has been fully authenticated to Alice.

	d: Using the hash(K, R_Alice, R_Bob), four keys are produced by Alice.
	e1: Key encryption write:  8e3ffebe8d268630
	e2: Key encryption read:  cb5b57aa3a630ff9
	e3: Key integrity protection write:  2d3fa43b0848c5dd
	e4: Key integrity protection read:  6e65f62c8fb345ad

	f: SSL Handhsake is complete

END OF HANDSHAKE PHASE


START OF DATA TRANSFER PHASE:

7. Go to Bob.py's terminal and read these outputs:

	a: Using SHA-256 integrity protection, like Alice requested, here is the HMAC of Key integrity protection_write, 
	   SEQ= 0  RH and block(aka a 4th of the data, 16KB): cc86cdab4285e5bc43fb695dfbb14d26ff59aa1e382a1f4754adf14931f0a7a7

	b: Then, Bob encrypts the block(aka a 4th of the data, 16 KB), HMAC and padding using AES by using his encryption_write key, 
	   like Alice requested.For space purposes, the ciphertext will not be printed in the terminal.

	c: Using SHA-256 integrity protection, like Alice requested, here is the HMAC of Key integrity protection_write, 
	   SEQ= 1  RH and block(aka a 4th of the data, 16KB): 19535aa04c292d21dd279baad8c5ca6383e4201e84775fd035ced789810e93ec

	d: Then, Bob encrypts the block(aka a 4th of the data, 16 KB), HMAC and padding using AES by using his encryption_write key, 
	   like Alice requested.For space purposes, the ciphertext will not be printed in the terminal.

	e: Using SHA-256 integrity protection, like Alice requested, here is the HMAC of Key integrity protection_write, 
	   SEQ= 2  RH and block(aka a 4th of the data, 16KB): c34e74591d8adfe44b00703e6e8fbc420adb720105bd8ab3bf9630759d58bf76

	f: Then, Bob encrypts the block(aka a 4th of the data, 16 KB), HMAC and padding using AES by using his encryption_write key, 
	    like Alice requested.For space purposes, the ciphertext will not be printed in the terminal.

	g: Using SHA-256 integrity protection, like Alice requested, here is the HMAC of Key integrity protection_write, 
	   SEQ= 3  RH and block(aka a 4th of the data, 16KB): d5aa9bb837fa40b0673e12bfaa7df64fc9f911e5d080c5998ac5ed53ad656272
	
	h: Then, Bob encrypts the block(aka a 4th of the data, 16 KB), HMAC and padding using AES by using his encryption_write key, 
	   like Alice requested.For space purposes, the ciphertext will not be printed in the terminal.

	i: After the 4 encrypted blocks have been appended together into one message, Bob will send that encrypted message(aka the file) to Alice.
	
8. Go to Alice.py's terminal and read these outputs:

	a: Alice has received the encrypted message(aka the file) from Bob.

	b: Alice decrypts block  0  of 3 using AES, by using her encryption_read key. For space purposes the decrypted block(16 KB of letters) will not be displayed here.
	
	c: Using SHA-256 integrity protection, here is the HMAC, that Alice generates, of Key integrity protection_read, 
	   SEQ= 0  RH and block(aka a 4th of the data, 16KB): b'cc86cdab4285e5bc43fb695dfbb14d26ff59aa1e382a1f4754adf14931f0a7a7'
	d: This is the hmac that Bob sent for the corresponding block:  b'cc86cdab4285e5bc43fb695dfbb14d26ff59aa1e382a1f4754adf14931f0a7a7'
	e: Block  0  is verified.

	f: Alice decrypts block  1  of 3 using AES, by using her encryption_read key. For space purposes the decrypted block(16 KB of letters) will not be displayed here.

	g: Using SHA-256 integrity protection, here is the HMAC, that Alice generates, of Key integrity protection_read, 
	   SEQ= 1  RH and block(aka a 4th of the data, 16KB): b'19535aa04c292d21dd279baad8c5ca6383e4201e84775fd035ced789810e93ec'
	h: This is the hmac that Bob sent for the corresponding block:  b'19535aa04c292d21dd279baad8c5ca6383e4201e84775fd035ced789810e93ec'
	i: Block  1  is verified.

	j: Alice decrypts block  2  of 3 using AES, by using her encryption_read key. For space purposes the decrypted block(16 KB of letters) will not be displayed here.

	k: Using SHA-256 integrity protection, here is the HMAC, that Alice generates, of Key integrity protection_read, 
	   SEQ= 2  RH and block(aka a 4th of the data, 16KB): b'c34e74591d8adfe44b00703e6e8fbc420adb720105bd8ab3bf9630759d58bf76'
	l: This is the hmac that Bob sent for the corresponding block:  b'c34e74591d8adfe44b00703e6e8fbc420adb720105bd8ab3bf9630759d58bf76'
	m: Block  2  is verified.

	n: Alice decrypts block  3  of 3 using AES, by using her encryption_read key. For space purposes the decrypted block(16 KB of letters) will not be displayed here.
	o: Using SHA-256 integrity protection, here is the HMAC, that Alice generates, of Key integrity protection_read, 
	   SEQ= 3  RH and block(aka a 4th of the data, 16KB): b'd5aa9bb837fa40b0673e12bfaa7df64fc9f911e5d080c5998ac5ed53ad656272'
	p: This is the hmac that Bob sent for the corresponding block:  b'd5aa9bb837fa40b0673e12bfaa7df64fc9f911e5d080c5998ac5ed53ad656272'
	q: Block  3  is verified.

	r: All of the hashes were verified. Write output to file.

9. Open a new terminal and write this command on windows(diff is equivalent to FC in windows) to compare the file that Bob sent and 
   the file that Alice generated: 'FC alice_decrypted_random_words.txt bob_random_words.txt'

--------------------------------------------------------------------------------------------



This is a corrupt run(example) of the program. I will show you how to read the outputs in terminal.
I say example because variables will be different in each run.
--------------------------------------------------------------------------------------------

1. Run Bob.py and Alice.py in that order in 2 terminals. Set mode in line 106 of Alice.py to 'corrupt'.

START OF HANDSHAKE PHASE:

2. Go to Alice.py's terminal and read these outputs:

	a: R_Alice generated by Alice:  772877d2
	b: Alice has sent the first message to Bob, which contains a certificate signed by the public key of Alice(K_a), 
	   supported encryption algorithm which is AES, supported integrity protection algorithm which is SHA-256, and R_Alice

3. Go to Bob.py's terminal and read these outputs:

	a: Bob has received the first message from Alice, which contains a certificate signed by the public key of Alice(K_a), supported encryption 
	   algorithm which is AES, supported integrity protection algorithm which is sha256, and R_Alice
	b: By checking the certificate and who it is signed by, Bob determines that this is Alice
	c: Bob decodes the supported encryption algorithm(non-negotiable) to be: AES
	d: Bob decodes the supported integrity protection algorithm(non-negotiable) to be: sha256
	e: Bob decodes R_Alice to be: 8d12a1d6
	f: K_a: Public RSA key at 0x1F68FF1EC20
	g: R_Bob generated by Bob:  4316dbb5
	h: Using the certificate, Bob finds the public key of Alice and uses that to encrypt R_Bob
	i: Bob has sent the second message to Alice, which contains a certificate signed by the public key of Bob(K_b),and K_a{R_Bob}

4. Go to Alice.py's terminal and read these outputs:

	a: Alice has received the second message from Bob, which contains a certificate signed by the public key of Bob(K_b),and K_a{R_Bob}
	b: By checking the certificate and who it is signed by, Alice determines that this is Bob
	c: Alice decrypts R_Bob using her private key, which turns out to be: 4316dbb5
	d: K_b: Public RSA key at 0x140EBB93D60
	e: Alice generates a random number called S, which is: 82133ecc
	f: Alice computes the Master Secret K(S xor R_Alice xor R_Bob) to be: 4c1744af
	g: Alice has sent the third message to Bob, which contains K_b{S} and the combined hash of K, message 1, message 2 and "CLIENT"or"CORRUPT"

5: Go to Bob.py's terminal and read these outputs:

	a: Bob has received the third message from Alice, which contains K_b{S} and the combined hash of K, message 1, message 2 and "CLIENT" or "CORRUPT"
	b: Bob decrypts S, using his private key, to be: d64e8437
	c: Bob computes the Master Secret K(S xor R_Alice xor R_Bob) to be: 2c1aa7a

	d1: Bob will find the keyed hash function, which is a digest of K, message 1, message 2 and "CLIENT"/"CORRUPT"
	d2: Bob just generated K, he knows message 1 and message 2 and he can generate a string "CLIENT"/"CORRUPT"
	d3: Bob will know do a hash on his end by using K, message 1, message 2 and "CLIENT"/"CORRUPT"
	d4: If the hash that Bob generated matches the hash that Alice sent, Alice has been fully authenticated to Bob

	e: Since the hashes do not match, this is not Alice. OR, Alice sent a "CORRUPT" string. Exit handshake.

6. Go to Alice.py's terminal and read these outputs:

	a: Alice should receive the fourth message from Bob, which contains the combined hash of K, message 1, message 2 and "SERVER"
	b: Bob did not send anything, which means Alice made a mistake in the handshake process by using the string "CORRUPT". Exit handshake.

--------------------------------------------------------------------------------------------

Specifications that I used and some explanations:

	a: X509 certificates to create certificates for both Alice and Bob.
	b: Alice can only use AES and SHA-256. Simply put, Bob cannot choose and has to use those 2. During data transfer, 
	   Bob will use AES for encryption and SHA-256 for integrity protection.
	c: K = S xor R_Alice xor R_Bob
	d: Using the hash of K, R_Alice and R_Bob to generate 4 keys.
	e: During data transfer, Bob uses his write integrity protection key to hash and his write encryption key to encrypt.
	f: During data transfer, Alice uses her read integrity protection key to verify the hash that Bob sent and her 
	   read encryption key to decrypt the encrypted file that Bob sent.
	g: A failed verification of key hashes can be simulated by changing line 106 in Alice.py to 'corrupt'. 
	h: A normal verification can be simulated by hanging line 106 in Alice.py to 'good'. 
	i: Bob encrypts and does integrity protection on the file 'bob_random_words.txt'. Alice decrypts the 
	   encrypted file that Alice sent and writes it on 'alice_decrypted_random_words.txt'. 
	j: Write the command(on a windows terminal) 'FC bob_random_words.txt alice_decrypted_random_words.txt' to do a diff 
	   for both files. I do not know what the linux or MacOS equivalent is.
	k: Finally, I am uploading Alice.py, Bob.py bob_random_words.txt and this README file. alice_decrypted_random_words.txt 
	   will appear on the code directory once you run both Bob.py and Alice.py

